<%# Constructs equal case for method -%>
<%
func equalCase(_ method: SourceryRuntime.Method) -> String {    
    return "case (.\(method.shortName), .\(method.shortName)): return true" //FIXME: now always return true for the same signature, add matching in future releases
    if method.parameters.isEmpty {
        return "case (.\(method.shortName), .\(method.shortName)): return true"
    } else {
        return "case (let .\(method.shortName)(lhsParams), let .\(method.shortName)(rhsParams)): return lhsParams == rhsParams"
    }
}
-%>

<%# Constructs proxy for given paraeteters and return type -%>
<%
func proxyConstructor(_ method: SourceryRuntime.Method) -> String {    
    if method.parameters.isEmpty {
        return "return MethodProxy(method: .\(method.shortName), returns: willReturn)"
    } else {
        let parameters = method.parameters.map { "\($0.name): \($0.name)" }.joined(separator: ", ")
        return "return MethodProxy(method: .\(method.shortName)(\(parameters)), returns: willReturn)"
    }
}
-%>
<%# Constructs proxy method name for given method -%>
<% 
func proxyConstructorName(_ method: SourceryRuntime.Method) -> String {
    if method.parameters.isEmpty {
        return "static func \(method.shortName)(willReturn: \(method.returnTypeName)) -> MethodProxy"
    } else {
        let functionParameters = method.parameters.map { "\($0.name): Parameter<\($0.typeName)>" }.joined(separator: ", ")
        return "static func \(method.shortName)(\(functionParameters), willReturn: \(method.returnTypeName)) -> MethodProxy"
    }
}   
-%>
<%# Constructs enumerated method name and parameters -%>
<%
func methodDeclarationWithParameters(_ method: SourceryRuntime.Method) -> String {

    if method.parameters.isEmpty {
        return method.shortName
    }
    let parameters = method.parameters
    .map {  return "\($0.name) : Parameter<\($0.typeName.name)>" }
    .joined(separator: ",")
    .replacingOccurrences(of: "@escaping", with: "")
    return "\(method.shortName)(\(parameters))"
}
-%>


<%# Constructs default method implementation -%>
<%# Example: addInvocation(.simpleCall(parameter: .value(parameter))) -%>
<% 
func methodImplementation(_ method: SourceryRuntime.Method) -> String {
    var array: [String] = []
    if method.returnTypeName.isVoid {
        array.append("func \(method.name) {")
    } else {
        array.append("func \(method.name) -> \(method.returnTypeName.name) {")
    }
    
    if !method.returnTypeName.isVoid {
        if method.parameters.isEmpty {
            array.append("; return methodReturnValue(.\(method.shortName)) as! \(method.returnTypeName) ")
        } else {
            let parameters = method.parameters.map { "\($0.name): .value(\($0.name))" }.joined(separator: ", ")
            array.append("; return methodReturnValue(.\(method.shortName)(\(parameters)))) as! \(method.returnTypeName) ")        
        }
    }
    array.append("}")
    return array.joined(separator: "  ")
}
-%>

<%# Constructs default method implementation prototype -%>
<%# Example: func getExampleItem(some: Parameter) -> Item -%>
<% 
func stubPrototype(_ method: SourceryRuntime.Method) -> String {
    var array: [String] = []
    if method.returnTypeName.isVoid {
        return "func \(method.name) "
    } else {
        return "func \(method.name) -> \(method.returnTypeName.name) "
    }
}
-%>

<%# Constructs adding invocation to invocations list -%>
<%# Example: func getExampleItem(some: Parameter) -> Item -%>
<% 
func addInvocation(_ method: SourceryRuntime.Method) -> String {
    if method.parameters.isEmpty {
        return "addInvocation(.\(method.shortName))"
    } else {
        let parameters = method.parameters.map { "\($0.name): .value(\($0.name))" }.joined(separator: ", ")
        return "addInvocation(.\(method.shortName)(\(parameters)))"
    }
}
-%>

<%# Constructs default method implementation prototype -%>
<%# Example: func getExampleItem(some: Parameter) -> Item -%>
<% 
func retrunIfNeeded(_ method: SourceryRuntime.Method) -> String {
    guard !method.returnTypeName.isVoid else { return "" }
    if method.parameters.isEmpty {
        return "return methodReturnValue(.\(method.shortName)) as! \(method.returnTypeName) "
    } else {
        let parameters = method.parameters.map { "\($0.name): .value(\($0.name))" }.joined(separator: ", ")
        return "return methodReturnValue(.\(method.shortName)(\(parameters))) as! \(method.returnTypeName) "        
    } 
}
-%>

<%# implement variable for Optional types and IUO, for other add marker that you need to implement those yourself in non-genreated code scope-%>
<%# TODO: make examples for all types of properties with different kinds of accesors-%>
<% 
func stubProperty(_ variable: SourceryRuntime.Variable) -> String {
    if variable.isOptional || variable.isImplicitlyUnwrappedOptional {
        return "var \(variable.name): \(variable.typeName)"
    } else {
        return "// var \(variable.name): \(variable.typeName) - not supported"
    }
}
-%>

<% for type in types.all {  
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue } 
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked
    //swiftlint:disable force_cast

    var invocations = [MethodType]()
    var methodReturnValues: [MethodProxy] = []

    //MARK : <%= aProtocol.name %>
    <%_ for variable in aProtocol.allVariables { %> 
    <%= stubProperty(variable) -%>
    <% } %> <%_ -%>

    <%_ for method in aProtocol.allMethods { %>
    <%= stubPrototype(method) _%> {
        <%= addInvocation(method) _%> 
        <%= retrunIfNeeded(method) _%> 
    }
    <%  } %> <%_ -%>

    enum MethodType: Equatable {
    <%_ for method in aProtocol.allMethods { _%>
        case <%= methodDeclarationWithParameters(method) -%>
    <%  } %> 
    <%_ -%>    
        static func ==(lhs: MethodType, rhs: MethodType) -> Bool {
            switch (lhs, rhs) {
                <%_ for method in aProtocol.allMethods { %>
                <%= equalCase(method) -%>
                <%  } %> 
                <%_ -%>
                default: return false   
            }
        }
    }

    struct MethodProxy {
        var method: MethodType 
        var returns: Any? 
        <%_ for method in aProtocol.methods { %>
        <%= proxyConstructorName(method) -%> {
            <%= proxyConstructor(method) _%>
        }
        <%  } %> <%_ -%> 
    }

    private func methodReturnValue(_ method: MethodType) -> Any? {
        let all = methodReturnValues.filter({ proxy -> Bool in
            return proxy.method == method
        })

        return all.last?.returns
    }

// sourcery:end
<% }
} -%>