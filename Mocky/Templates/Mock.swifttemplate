<%# Constructs proxy for given paraeteters and return type -%>
<%
func proxyConstructor(_ method: Method) -> String {    
    if method.parameters.isEmpty {
        return "return MethodProxy(method: .\(method.shortName), returns: willReturn)"
    } else {
        let parameters = method.parameters.map { "\($0.name): \($0.name)" }.joined(separator: ", ")
        return "return MethodProxy(method: .\(method.shortName)(\(parameters)), returns: willReturn)"
    }
}
-%>
<%# Constructs profy method name for given method -%>
<% 
func proxyConstructorName(_ method: Method) -> String {
    if method.parameters.isEmpty {
        return "static func \(method.shortName)(willReturn: \(method.returnTypeName)) -> MethodProxy {"
    } else {
        let functionParameters = method.parameters.map { "\($0.name): Parameter<\($0.typeName)>" }.joined(separator: ", ")
        return "static func \(method.shortName)(\(functionParameters), willReturn: \(method.returnTypeName)) -> MethodProxy {"
    }
}   
-%>
<%# Constructs enumerated method name and parameters -%>
<%
func methodDeclarationWithParameters(_ method: Method) -> String {

    if method.parameters.isEmpty {
        return method.shortName
    }
    let parameters = method.parameters
    .map {  return "\($0.name) : Parameter<\($0.typeName.name)>" }
    .joined(separator: ",")
    .replacingOccurrences(of: "@escaping", with: "")
    return "\(method.shortName)(\(parameters))"
}
-%>
<%# Constructs default method implementation -%>
<%# Example: addInvocation(.simpleCall(parameter: .value(parameter))) -%>
<% 
func methodImplementation(_ method: Method) -> String {
    var array: [String] = []
    if method.returnTypeName.isVoid {
        array.append("func \(method.name) {")
    } else {
        array.append("func \(method.name) -> \(method.returnTypeName.name) {")
    }
    
    if method.parameters.isEmpty {
        array.append("addInvocation(.\(method.shortName))")
    } else {
        let parameters = method.parameters.map { "\($0.name): .value(\($0.name)" }.joined(separator: ", ")
        let methodInvocation = "addInvocation(.\(method.shortName)(\(parameters))))"
        array.append(methodInvocation)
    }
    
    if !method.returnTypeName.isVoid {
        if method.parameters.isEmpty {
            array.append("; return methodReturnValue(.\(method.shortName)) as! \(method.returnTypeName) ")
        } else {
            let parameters = method.parameters.map { "\($0.name): .value(\($0.name)" }.joined(separator: ", ")
            array.append("; return methodReturnValue(.\(method.shortName)(\(parameters)))) as! \(method.returnTypeName) ")        
        }
        
        
    }
    array.append("}")
    return array.joined(separator: "  ")
}
-%>
<%# case equality check generation for given method -%>
<%
func caseEqualityForMethod(_ method: Method) -> String {
    if method.parameters.isEmpty {
        return "(.\(method.shortName), .\(method.shortName)): return true"
    } else {
        return "(let .\(method.shortName)(lhsParams), let .\(method.shortName)(rhsParams)): return lhsParams == rhsParams"
    }
}
-%>
<% for type in types.all {  
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue } 
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked

    var invocations = [ParameterType]()
    var methodReturnValues: [MethodProxy] = []

    <%_ for method in aProtocol.methods { %>
    <%= methodImplementation(method) -%>
    <%  } %> 
    <%_ -%>


    enum ParameterType : Equatable {
        <%_ for method in aProtocol.methods { %>
        case <%= methodDeclarationWithParameters(method) -%>
        <%  } %> 
    
        static func ==(lhs: ParameterType, rhs: ParameterType) -> Bool {
            switch (lhs, rhs) {
            <%_ for method in aProtocol.methods { _%>
                case <%= caseEqualityForMethod(method) -%>
            <%  } %> 
                default: return false    
            }
        }
    }

    struct MethodProxy {
        var method: ParameterType
        var returns: Any?
        <%_ let returnMethods = aProtocol.methods.filter { !$0.returnTypeName.isVoid }; for method in returnMethods { %>
        <%= proxyConstructorName(method) _%>
            <%= proxyConstructor(method) _%>
        }
        <%  } %> 
    }


    private func methodReturnValue(_ method: ParameterType) -> Any? {
        let all = methodReturnValues.filter({ proxy -> Bool in
            return proxy.method == method
        })

        return all.last?.returns
    }

// sourcery:end
<% }
} -%>