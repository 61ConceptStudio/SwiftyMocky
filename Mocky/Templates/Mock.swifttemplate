<%# Constructs enumerated method name -%>
<%
func methodDeclaration(_ method: Method) -> String {
    return "case \(method.shortName)"
}
-%>
<%# Constructs enumerated method name and parameters -%>
<%
func enumReturnType(_ method: Method) -> String {
    if method.returnTypeName.isVoid {
        return ""
    }
    return "case \(method.shortName)(returns: \(method.returnTypeName))"
}
-%>
<%# Constructs enumerated method name and parameters -%>
<%
func methodDeclarationWithParameters(_ method: Method) -> String {

    if method.parameters.isEmpty {
        return method.shortName
    }
    let parameters = method.parameters
    .map {  return "\($0.name) : Parameter<\($0.typeName.name)>" }
    .joined(separator: ",")
    .replacingOccurrences(of: "@escaping", with: "")
    return "\(method.shortName)(\(parameters))"
}
-%>
<%# Constructs default method implementation -%>
<%# Example: addInvocation(.simpleCall(parameter: .value(parameter))) -%>
<% 
func methodImplementation(_ method: Method) -> String {
    var array: [String] = []
    if method.returnTypeName.isVoid {
        array.append("func \(method.name) {")
    } else {
        array.append("func \(method.name) -> \(method.returnTypeName.name) {")
    }
    
    if method.parameters.isEmpty {
        array.append("addInvocation(.\(method.shortName))")
    } else {
        let parameters = method.parameters.map { "\($0.name): .value(\($0.name)" }.joined(separator: ", ")
        let methodInvocation = "addInvocation(.\(method.shortName)(\(parameters))))"
        array.append(methodInvocation)
    }
    
    if !method.returnTypeName.isVoid {
        array.append("; return returnValue(.\(method.shortName) )")    
    }
    array.append("}")
    return array.joined(separator: "  ")
}
-%>
<%# case equality check generation for given method -%>
<%
func caseEqualityForMethod(_ method: Method) -> String {
    if method.parameters.isEmpty {
        return "(.\(method.shortName), .\(method.shortName)): return true"
    } else {
        return "(let .\(method.shortName)(lhsParams), let .\(method.shortName)(rhsParams)): return lhsParams == rhsParams"
    }
}
-%>
<% for type in types.all {  
    guard let protocolToDecorate = type.annotations["mock"] as? String else { continue } 
    if let aProtocol = types.protocols.first(where: { $0.name == protocolToDecorate }) { -%>
    // sourcery:inline:auto:<%= type.name %>.autoMocked

    var returnValues: [ReturnType] = []
    var invocations = [ParameterType]()

    <%_ for method in aProtocol.methods { %>
    <%= methodImplementation(method) -%>
    <%  } %> 
    <%_ -%>

enum SignatureType {
    <%_ for method in aProtocol.methods { %>
    <%= methodDeclaration(method) -%>
    <%  } %>
}

enum ParameterType : Equatable {
    <%_ for method in aProtocol.methods { %>
    case <%= methodDeclarationWithParameters(method) -%>
    <%  } %> 
    
    static func ==(lhs: ParameterType, rhs: ParameterType) -> Bool {
        switch (lhs, rhs) {
        <%_ for method in aProtocol.methods { _%>
            case <%= caseEqualityForMethod(method) -%>
        <%  } %> 
            default: return false    
        }
    }
}

enum ReturnType: AutoValue {
    <%_ for method in aProtocol.methods { %>
    <%= enumReturnType(method) -%>
    <%  } %>
}
// sourcery:end
<% }
} -%>